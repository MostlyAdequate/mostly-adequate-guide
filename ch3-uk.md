# Частина 3: Справжнє щастя з чистими функціями

## О, знову бути чистими

Одина річ яка нам потрібна, це ідея чистоти функції.

>Чиста функція, це така функція, котра, при однакових вхідних данних, завжди повертатиме однаковий результат і не має жодних видимих побічних ефектів.

Візьмемо, наприклад, `slice` та `splice`. Це дві функції, які роблять точнісінько одну й ту саму річ, нехай і у абсолютно різний спосіб, подумали ви, але все ж таки одну й ту саму річ. Ми кажемо `slice` є *чистою*, бо вона кожен раз гарантовано повертає одноковий результат. `splice`, натомість, пережує отриманий масив та виплюне назавжди змінений, що є нічим іншим як видимим побічним ефектом. 

```js
var xs = [1, 2, 3, 4, 5];

// чисто:
xs.slice(0, 3);
//=> [1, 2, 3]

xs.slice(0, 3);
//=> [1, 2, 3]

xs.slice(0, 3);
//=> [1, 2, 3]


// не чисто:
xs.splice(0, 3);
//=> [1, 2, 3]

xs.splice(0, 3);
//=> [4, 5]

xs.splice(0, 3);
//=> []
```

У функціональному програмуванні ми зневажаємо, так би мовити, функція як от `splice`, які *мутують(змінюють)* данні. Нам таке не підходить, оскільки ми прагнемо покладатись на надійні функції, котрі завжди повертають один й той самий результат, а не лишають за собою безлад, як це робить метод `splice`.

Давайте розглянемо інший приклад.

```js
// не чисто:
var minimum = 21;

var checkAge = function(age) {
  return age >= minimum;
};



// чисто
var checkAge = function(age) {
  var minimum = 21;
  return age >= minimum;
};
```

У "не чистій" частині, функція `checkAge` у своїх підрахунках залежить від змінюємої(мутабельної) змінної `minimum`. Інакше кажучи, вона залежить від стану середовища, що не може не засмучувати, оскільки воно збільшує когнітивне навантаження шляхом введення зовнішнього середовища (а тепер зверніть увагу на назву книги, ключове слово - "переважно", переважно адекватне :) ).

У цьому прикладі це може здатись не на стільки вже й значущою проблемою, але ця залежність від стану є одним із основних внесків у складність всієї системи.(http://www.curtclifton.net/storage/papers/MoseleyMarks06a.pdf). Ця функція `checkAge` може повертати різні результати в залежності від факторів, котрі є сторонніми по відношенню до вхідних данних, що не тільки віддаляє її від так званої "чистоти", але ще й змушує нас напрягатись кожен раз, коли ми розмірковуємо над програмним забезпеченням.

А от ця чиста форма - абсолютно самодостатня. Ми можемо також зробити `minimum` іммутабельним(незмінюваним), що збереже чистоту, осткільки стан ніколи не зміниться. Щоб зробити це, нам потрібно всього лиш створити "заморожений" об'єкт.

```js
var immutableState = Object.freeze({
  minimum: 21,
});
```

## Під побічними ефектами ми розуміємо...

Давайте більш детальніше поглянемо на ці "побічні ефекти", для того, щоб покращити нашу інтуіцію. То щож це за такі мерзенні *побічні ефекти* про які згадувалось у визначенні *чистої функції*? Ми будемо посилатись на *ефекти*, як щось, що стається під час виконання наших розрахунків і не є безпосереднім вираховуванням результату.

Власне кажучи, немає нічого поганого в ефектах і ми будемо використовувати їх усюди а наступних розділах. А от *побічні* - це саме те, що несе в собі додаткове і негативне значення. Вода, сама по собі, не є інкубатором для личинок, але це *застій* води призводить до їх розмноження, і я вас запевняю, що *побічні* ефекти - це таке саме середовище в наших програмах.

>*Побічний ефект* - це зміна стану системи чи *видима взаємодія* з зовнішнім світом, що виникає в ході вирахунку результату.

Побічні ефекти включаються в себе(і не обмежуються лише цим переліком)

  * зміна файлової системи
  * внесення запису у базу данних
  * виконання http запиту
  * мутації
  * вивід на екран / логування
  * одержання користувацького вводу
  * запит до DOM
  * доступ до стану системи

І цей перелік можна продовжувати і продовжувати. Будь-яка взаємодія зі світом, який знаходиться поза межами функції є побічним ефектом, який, напевно, змусить вас засумніватися в практичності програмування без їх використання. Філософія функціонального програмування стоїть горою на тому, що побічні ефекти є головною причиною неправильної поведінки.

Не те щоб нам було суворо забороненно їх використовувати, ні, ми радше воліємо опанувати їх і використовувати контрольовано. Ми вивчимо як це робити, коли дістанемось до функторів і монад в подальших розділах, але покищо, давайте тримати ці підступні функції окремо від наших чистих.

Через побічні ефекти функція припиняє бути *чистою*. І в цьому є сенс: чисті функції, за визначенням, мають завжди повертати однаковий результат при однакових вхідних даних, що неможливо гарантувати, коли щось залежить від оточуючого світу поза межами конкретної функції.

Давайте більш ретельно розглянемо, чому ми наполягаємо на однакових результатах при однакових вхідних даних. Підніміть ваші комірці, бо зараз ми з вами поглянемо на математику за 8ий клас.

## Математика за 8ий клас

З mathisfun.com:

> Функція - спеціальни зв'язок між значеннями:
> Кожна її вхідна величина віддає рівно одне вихідне значення.

Інакше кажучи, це лише зв'язок між двума величинами: вхідними даними та результатом. Не дивлячись на те, що кожена вхідна величина має конкретно одне кінцеве значення, це не означає що кінцеве значення мусить бути унікальним для кожнної вхідної величини. Нижче наведена діаграма з ідеально валідною функцією:

<img src="images/function-sets.gif" alt="function sets" />(http://www.mathsisfun.com/sets/function.html)

На противагу цьому, наступна діаграмма демонструє зв'язок, що *не* є функцією, оскільки значення вхідної величини(`5`) веде до кількох рузельтатів:

<img src="images/relation-not-function.gif" alt="relation not function" />(http://www.mathsisfun.com/sets/function.html)

Фунції можуть бути описані як набір пар з положенням (вхідна величина, результат): `[(1,2), (3,6), (5,10)]` (Схоже на те, що ця функція подвоює отримувану величину).

Чи можлива таблиця:
<table> <tr> <th>Вхідна величина</th> <th>Результат</th> </tr> <tr> <td>1</td> <td>2</td> </tr> <tr> <td>2</td> <td>4</td> </tr> <tr> <td>3</td> <td>6</td> </tr> </table>

Чи навіть графік з `x` як вхідна величина та `y` як результат:

<img src="images/fn_graph.png" width="300" height="300" alt="function graph" />


Немає жодної потреба в деталях реалізації, до тих пір, поки вхідна величина диктує результат. А оскільки функції є простими поєднаннями вхідних величини та результатів, то можна побачити, що модна прибрати фігурні дужки і запустити функцію з `[]` замість `()`.

```js
var toLowerCase = {
  'A': 'a',
  'B': 'b',
  'C': 'c',
  'D': 'd',
  'E': 'e',
  'F': 'f',
};

toLowerCase['C'];
//=> 'c'

var isPrime = {
  1: false,
  2: true,
  3: true,
  4: false,
  5: true,
  6: false,
};

isPrime[3];
//=> true
```

Звісно, ви можете захотіти вираховувати замість вручну виписувати результати, але це демонструє різні способи думати про функції. (Ви можете подумати "а що ж щодо функції з кількома аргументами?". Дійсно, це трохи незручно, коли мислимо з точки зору математики. Покищо, ми можемо скласти їх в масив чи просто думати про об'єкт `arguments` як про вхідну величину. Коли ми почнемо вчити _каррування_, ми побачимо, як ми можемо безпосередньо моделювати математичне визначення функції).

І тут настає драматичне відкриття: чисті функції - це математичні функції, і саме це - функціональне програмування. Програмування за допомогою цих маленьких ангелів може забезпечити величезну користь. Давайте розглянемо деякі причини, чому ми можемо вдатись до великих довжин, заради збереження чистоти.

## Випадок для чистоти

### Здатність до кешування

Для початку, чисті функції завжди можуть бути закешовані вхідною величиною. Це робиться за допомогою техніки, яка називається _мемоізація_(memoization):

```js
var squareNumber = memoize(function(x) {
  return x * x;
});

squareNumber(4);
//=> 16

squareNumber(4); // повертає кеш для вхіного значення 4
//=> 16

squareNumber(5);
//=> 25

squareNumber(5); // повертає кеш для вхіного значення 5
//=> 25
```

Ось проста реалізація, хоча існує безліч більш надійних версій.

```js
var memoize = function(f) {
  var cache = {};

  return function() {
    var arg_str = JSON.stringify(arguments);
    cache[arg_str] = cache[arg_str] || f.apply(f, arguments);
    return cache[arg_str];
  };
};
```

Варто відзначити, що ви можете перетворити деякі не чисті функції у чисті за допомогою відтермінування обчислення(evaluation):

```js
var pureHttpCall = memoize(function(url, params) {
  return function() {
    return $.getJSON(url, params);
  };
});
```

Цікавий момент тут це те, що ми не виконуємо http запит - ми, натомість, повертаємо функцію, яка виконає запит в момент коли її викличуть. Ця функція є чистою, бо вона завжди поверне однаковий результат при одному й тому самому вхідному значенні: фунцію, що виконає конкретний http запит з аргументами `url` та `params`.

Наша `memoize` функція працює чудово, не дивлячись на те, що вона не кешує результат http запиту, бо вона кешує згенеровану функцію.

Це, покищо, не дуже корисно, але ми скоро вивчимо деякі фокуси, які нам в цьому допоможуть. Висновок полягає в тому, що ми можемо кешувати кожну функцію, в не залежності наскільки руйнівною вона виглядає.

### Портативність / Само-задокументованість

Чисті функції повністю автономні. Все що потрібно функції передається в неї, як на срібній таці. Обдумайте це хвилинку... Але як це може бути користим? Ну, для початку, залежності функції є явними, тому їх простіше бачити і розуміти - жодних смішних процесів під капотом.

```js
//не чиста
var signUp = function(attrs) {
  var user = saveUser(attrs);
  welcomeUser(user);
};

var saveUser = function(attrs) {
    var user = Db.save(attrs);
    ...
};

var welcomeUser = function(user) {
    Email(user, ...);
    ...
};

//чиста
var signUp = function(Db, Email, attrs) {
  return function() {
    var user = saveUser(Db, attrs);
    welcomeUser(Email, user);
  };
};

var saveUser = function(Db, attrs) {
    ...
};

var welcomeUser = function(Email, user) {
    ...
};
```

Цей приклад демострує, що чиста функція має бути чесною про свої залежності і тому каже нам точно про що вона. Вже по її сигнатурі ми знаємо, що вона буде використовувати `Db`, `Email`, та `attrs`, і це важливо це продемонструвати.

Ми вивчимо, як робити функції чистими як ця без відкладеного обчислення(evaluation), але має бути чітко зрозуміло, що чиста форма набагато інформативніша, аніж її підступна та слизька аналогія, про яку лише Богові відомо, що і як вона робить насправді.

Іще важливо відзначити, що ми змушені "вставляти"("inject") залежності чи передавати їх в якості аргументів, що робить нашу програму більш гнучкою, бо ми параметризували нашу базу даних чи поштовий клієнт чи будь що ще (не хвилюйтесь, ми побачимо як робити це менш неприємним ніж воно звучить). Якщо ми раптом вирішили використовувати іншу базу даних, нам лише потрібно викликати нашу функцію з цією залежністю. Якщо ми пишимо нову програму в якій ми хотіли б використати нашу надійну функцію - ми просто передаємо в неї будь-яку `Db` та `Email` яка нам потрібна в цьому випадку.

У JavaScript налаштування та портативність можуть значити серіалізацію та відправку функцій через сокет (socket). Це може означати, що весь код нашої програми може виконуватись у веб-воркерах (web workers). Портативність - дуже потужна риса.

На відміну від "типових" методів та процедур в імперативному програмуванні, глибоко занурених у їх оточення через стан, залежності та доступні ефекти, чисті функції можуть бути запущені будь-де, де наше серце тільки забажає.

Коли в останній раз ви скопіювали метод у нову програму? Одна з моїх улюблених цитат належить творцю Ерланга Джо Армстронгу: «Проблема з об'єктно-орієнтованими мовами - це все це неявне оточення, яке вони несуть із собою. Ви хотіли банан, але те, що ви отримали, - це горилла, яка тримає банан ... і всі джунглі".

### Гарна тестуємість

Наступним ми усвідомлюємо, що чисті функції роблять тестування значно простішим. Нам не потрібно робити заглушку(mock) зі "справжньою" відповіддю, чи налаштувати та зазначити стан програми після кожного тесту. Ми просто передаємо функції вхідне значення і зазначаємо вихідне.

Насправді, ми розуміємо, що функціональна спільнота розробляє нові новаторські інструменти тестування, які можуть вистрілювати наші функції зі згенерованими вхідними значеннями та стверджувати, що властивості все таки лишаються на виході. Це поза межами цієї книги, але я наполегливо рекомендую вам пошукати та спробувати *Quickcheck* - інструмент тестування, який призначений для суто функціонального середовища.

### Обгрунтованість

Багато людей вірять, що найбільшою перемогою, при роботі з чистими функціями є *референтна прозорість*. Шматок коду референтно прозорий тоді, коли він може бути замінений на його обчислений результат без зміни поведінки програми.

Оскільки чисті функції завжди повертають один й той самий результат при одній і тій самій вхідній величині, ми можемо покладатись на них, що вони повернуть той самий результат, і тому вони зберігають референтну прозорість. Давайте розглянемо приклад.

```js

var Immutable = require('immutable');

var decrementHP = function(player) {
  return player.set('hp', player.get('hp') - 1);
};

var isSameTeam = function(player1, player2) {
  return player1.get('team') === player2.get('team');
};

var punch = function(player, target) {
  return isSameTeam(player, target) ? target : decrementHP(target);
};

var jobe = Immutable.Map({
  name: 'Jobe',
  hp: 20,
  team: 'red',
});
var michael = Immutable.Map({
  name: 'Michael',
  hp: 20,
  team: 'green',
});

punch(jobe, michael);
//=> Immutable.Map({name:'Michael', hp:19, team: 'green'})
```

`decrementHP`, `isSameTeam` та `punch` - чисті функції і тому референтно прозорі. Для обмірковування коду, ми можемо використати техніку, яку називають *рівноправними міркуваннями*, де один замінює "рівними для рівних". Це трохи схоже на ручну оцінку коду без урахування примх програмної оцінки. Використовуючи референтну прозорість, давайте трохи пограємо з цим кодом.

Спочатку ми запишимо в одну строку функцію `isSameTeam`.

```js
var punch = function(player, target) {
  return player.get('team') === target.get('team') ? target : decrementHP(target);
};
```

Оскільки наші дані немутабельні, ми можемо просто замінити команди їхніми актуальними значеннями.

```js
var punch = function(player, target) {
  return 'red' === 'green' ? target : decrementHP(target);
};
```

Ми бачимо, що це `false` у цьому випадку, тож ми можемо прибрати усю if гілку

```js
var punch = function(player, target) {
  return decrementHP(target);
};

```

І якщо ми запишимо строкою `decrementHP` то побачимо, що, в цьому випадку, _punch_ перетворюється на виклик зменшення `hp` на 1.

```js
var punch = function(player, target) {
  return target.set('hp', target.get('hp') - 1);
};
```

Ця здатність до роздумів щодо коду надзвичайна для обробки/виправлення та розуміння коду взагалі. Насправді, ми використали цю техніку для виправлення нашої програми про чайок. Ми використовували порівняльні обгрунтовування, щоб використовувати властивості додавання та множення. І, насправді, ми будемо використовувати ці методи в усій книзі.

### Parallel Code

Finally, and here's the coup de grâce, we can run any pure function in parallel since it does not need access to shared memory and it cannot, by definition, have a race condition due to some side effect.

This is very much possible in a server side js environment with threads as well as in the browser with web workers though current culture seems to avoid it due to complexity when dealing with impure functions.


## In Summary

We've seen what pure functions are and why we, as functional programmers, believe they are the cat's evening wear. From this point on, we'll strive to write all our functions in a pure way. We'll require some extra tools to help us do so, but in the meantime, we'll try to separate the impure functions from the rest of the pure code.

Writing programs with pure functions is a tad laborious without some extra tools in our belt. We have to juggle data by passing arguments all over the place, we're forbidden to use state, not to mention effects. How does one go about writing these masochistic programs? Let's acquire a new tool called curry.

[Частина 4: Каррування.](ch4-uk.md)
